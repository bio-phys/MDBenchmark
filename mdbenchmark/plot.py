# -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-
# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8
#
# MDBenchmark
# Copyright (c) 2017 Max Linke & Michael Gecht and contributors
# (see the file AUTHORS for the full list of names)
#
# MDBenchmark is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MDBenchmark is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MDBenchmark.  If not, see <http://www.gnu.org/licenses/>.
#
# Written by Marc Siggel, January 2018
#
#
import os
import sys
from glob import glob

import click
import mdsynthesis as mds
import numpy as np
import pandas as pd
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
from matplotlib.figure import Figure

from .cli import cli
from .utils import calc_slope_intercept, guess_ncores, lin_func, detect_md_engine, formatted_md_engine_name
import mdengines.gromacs
import mdengines.namd


@cli.command()
@click.option(
    '-n',
    '--names',
    help='name of the input file',
    default='',
    multiple=True,
    show_default=True)
@click.option(
    '-nh',
    '--no-host',
    is_flag=True,
    help='show no host names in csv plot',
    show_default=True)
@click.option(
    '-nm',
    '--no-module',
    is_flag=True,
    help='show no module name in csv plot',
    show_default=True)
@click.option(
    '-o',
    '--output-names',
    default='',
    help="name of output PDF files"
    show_default=True)
@click.option(
    '-m',
    '--merge',
    is_flag=True,
    help="merge csv files to one output"
    show_default=True)
@click.option(
    '-t',
    '--plot-seperate',
    is_flag=True,
    help="plot each unique run seperately"
    show_default=True)
def plot(name, output_names, no_host, no_module, merge, plot_separate):
    """generate plots of csv files generated by analyze.
    """

    if not names:
        names = glob.glob('*.csv')
    elif len(names) == len(output_name):
        click.echo(
            'Input file count do not match output file count'
            'use --name to specify csv'.format(
                click.style('ERROR', fg='red', bold=True)))
        sys.exit(0)

    #if nothing found exit process
    if not names:
        click.echo(
            'No .csv files were found or provided!'
            'use --name to specify csv'.format(
                click.style('ERROR', fg='red', bold=True)))
        sys.exit(0)


    if merge:
        for n in names:
            tmp_df = pd.read_csv(n)
            #append df_list


            df = pd.concat(df_list)
            merged_name = concat names
            merged_name = '{}.pdf'.format(date_time)
            df.to_csv(merged_name)

            if df['gpu'].empty and df[~df['gpu']].empty:
                click.echo('There is no data to plot.')
                sys.exit(0)

            if not output_name:
                output_name = generate_output_name()

        plot_analysis(df, ncores, output_name, no_host, no_module, plot_separate)

    else:
        for n in names:
            df = pd.read_csv(n)
            #here we should get the same output in the end

            ##allow for multiple file read in here:
            ##set multiple file names if multiples have been set

            ### legacy code delete!

            # Fail if we have no values at all. This should be some edge case when
            # a user fumbles around with the datreant categories
            if df['gpu'].empty and df[~df['gpu']].empty:
                click.echo('There is no data to plot.')
                sys.exit(0)

            if not output_name:
                output_name = generate_output_name()


            plot_analysis(df, ncores, output_name, no_host, no_module, plot_separate)



def plot_analysis(df, ncores, output_name, no_host, no_module, plot_separate):

    df_list = split_dataframe(df)
    num_plots = len(df_list)


    # We have to use the matplotlib object-oriented interface directly, because
    # it expects a display to be attached to the system, which we don't on the
    # clusters.
    f = Figure()
    FigureCanvas(f)

    axs = {}
    if plot_separate:
        #dictionary
        w, h = get_figure_grid(num_plots)

        for p in range(1, num_plots):

             axs[p] = f.add_subplot(w, h, p)
             add_plot(axs, p, df_list[p])

    else:

        axs[1] = f.add_subplot(111)
        for p in range(1, num_plots):

            add_plot(axs, p, df_list[p])


    ax.legend()

    f.tight_layout()
    f.savefig(output_name, format='pdf')



def generate_output_name():
    date_time = dt.datetime.now().strftime("%y-%m-%d-%H_%M")
    out = '{}.pdf'.format(date_time)
    return out


def split_dataframe(df):

    df_list = []
    module_names = df.module.unique()
    for module in module_names:
        if module && gp:
        df_list[module,"gpu"], df_list[module,"no_gpu"] = [x for _, x in df.groupby(df['gpu'] = True)]
        else:
    ##something something        

    return df_list


def get_figure_grid(df_list):
#shitty test -> filter through certain rations so the plots stay square
    length_df = len(df_list)
    xlength = 3
    ylength = 4

    return xlength, ylength


def add_plot(axs, plot_index, df_segment):

     max_x = df['nodes'].max()
     max_y = df['ns/day'].max()
     if not max_y:
         max_y = 50

     y_tick_steps = 10
     if max_y > 100:
         y_tick_steps = 20

     x = np.arange(1, max_x + 1, 1)

    if not df[~df['gpu']].empty:
        cpu_data = df[(~df['gpu'])].sort_values('nodes').reset_index()
        axs[plot_index].plot(cpu_data['ns/day'], '.-', ms='10', color='C0', label='CPU')
        slope, intercept = calc_slope_intercept(x[0], cpu_data['ns/day'][0],
                                                x[1], cpu_data['ns/day'][1])

        ##plots the projection
        axs[plot_index].plot(
            x - 1,
            lin_func(x, slope, intercept),
            ls='dashed',
            color='C0',
            alpha=0.5)

    gpu_data = df[(df['gpu'])].sort_values('nodes').reset_index()

    if not gpu_data.empty:

        axs[plot_index].plot(gpu_data['ns/day'], '.-', ms='10', color='C1', label='GPU')
        slope, intercept = calc_slope_intercept(x[0], gpu_data['ns/day'][0],
                                                x[1], gpu_data['ns/day'][1])

        ##plots the projection
        axs[plot_index].plot(
            x - 1,
            lin_func(x, slope, intercept),
            ls='dashed',
            color='C1',
            alpha=0.5)

    axs[plot_index].set_xticks(x - 1)
    axs[plot_index].set_xticklabels(x)

    axTicks = axs[plot_index].get_xticks()

#    ax2 = ax.twiny()
#    ax2.set_xticks(axTicks)
#    ax2.set_xbound(ax.get_xbound())
#    if ncores is not None:
#        click.echo("Ncores overwritten from CLI. Ignoring values from simulation logs for plot.")
#        ax2.set_xticklabels(x for x in (axTicks + 1) * ncores)
#    else:
#        ax2.set_xticklabels(cpu_data['ncores'])

    axs[plot_index].set_xlabel('Number of nodes')
    axs[plot_index].set_ylabel('Performance [ns/day]')

    axs[plot_index].set_yticks(np.arange(0, (max_y + (max_y * 0.5)), y_tick_steps))
    axs[plot_index].set_ylim(ymin=0, ymax=(max_y + (max_y * 0.2)))

#    ax2.set_xlabel('{}'.format('{}\n\nCores'.format(df['host'][0])))
